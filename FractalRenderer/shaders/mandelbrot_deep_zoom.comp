#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f, set = 0, binding = 0) uniform image2D image;

// Reference orbit buffer for perturbation theory
layout(std140, set = 0, binding = 1) readonly buffer ReferenceOrbit {
    vec2 reference_orbit[];  // Complex numbers (real, imag)
};

layout(push_constant) uniform constants {
    vec4 data1; // center_x_hi, center_x_lo, center_y_hi, center_y_lo
    vec4 data2; // zoom_hi, zoom_lo, max_iterations, use_perturbation
    vec4 data3; // color_offset, color_scale, bailout, palette_mode
    vec4 data4; // samples_per_pixel, reference_iterations, use_series_approx, series_order
} PushConstants;

// Double-precision emulation for extreme zooms
struct DoubleDouble {
    float hi;
    float lo;
};

// Double-double arithmetic operations
DoubleDouble dd_add(DoubleDouble a, DoubleDouble b) {
    float t1 = a.hi + b.hi;
    float e = t1 - a.hi;
    float t2 = ((b.hi - e) + (a.hi - (t1 - e))) + a.lo + b.lo;
    
    DoubleDouble result;
    result.hi = t1 + t2;
    result.lo = t2 - (result.hi - t1);
    return result;
}

DoubleDouble dd_mul(DoubleDouble a, DoubleDouble b) {
    float p = a.hi * b.hi;
    float e = fma(a.hi, b.hi, -p);
    float f = fma(a.hi, b.lo, fma(a.lo, b.hi, e));
    
    DoubleDouble result;
    result.hi = p + f;
    result.lo = f - (result.hi - p);
    return result;
}

DoubleDouble dd_sub(DoubleDouble a, DoubleDouble b) {
    DoubleDouble neg_b;
    neg_b.hi = -b.hi;
    neg_b.lo = -b.lo;
    return dd_add(a, neg_b);
}

// Convert to single precision (for final iteration or bailout check)
float dd_to_float(DoubleDouble a) {
    return a.hi + a.lo;
}

// Create double-double from float
DoubleDouble float_to_dd(float x) {
    DoubleDouble result;
    result.hi = x;
    result.lo = 0.0;
    return result;
}

// Palette functions
vec3 palette_cosine(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

vec3 palette_fire(float t) {
    vec3 color1 = vec3(0.0, 0.0, 0.0);
    vec3 color2 = vec3(0.5, 0.0, 0.0);
    vec3 color3 = vec3(1.0, 0.5, 0.0);
    vec3 color4 = vec3(1.0, 1.0, 0.0);
    vec3 color5 = vec3(1.0, 1.0, 1.0);
    
    if (t < 0.25) return mix(color1, color2, t * 4.0);
    else if (t < 0.5) return mix(color2, color3, (t - 0.25) * 4.0);
    else if (t < 0.75) return mix(color3, color4, (t - 0.5) * 4.0);
    else return mix(color4, color5, (t - 0.75) * 4.0);
}

vec3 palette_ocean(float t) {
    vec3 color1 = vec3(0.0, 0.0, 0.2);
    vec3 color2 = vec3(0.0, 0.3, 0.6);
    vec3 color3 = vec3(0.0, 0.8, 0.8);
    vec3 color4 = vec3(0.5, 1.0, 1.0);
    
    if (t < 0.33) return mix(color1, color2, t * 3.0);
    else if (t < 0.66) return mix(color2, color3, (t - 0.33) * 3.0);
    else return mix(color3, color4, (t - 0.66) * 3.0);
}

vec3 get_palette_color(float t, int palette_mode) {
    if (palette_mode == 0) return palette_cosine(t);
    else if (palette_mode == 1) return palette_fire(t);
    else if (palette_mode == 2) return palette_ocean(t);
    else return palette_cosine(t);
}

// Series approximation coefficients for deep zoom optimization
// Skips early iterations using Taylor series expansion
int compute_series_skip(vec2 delta_c, int max_skip) {
    // Simple series approximation: check if we can skip iterations
    // For deep interior points, we can skip many iterations
    float dc_mag = length(delta_c);
    
    // Very rough heuristic: if delta is tiny, we can skip more
    if (dc_mag < 1e-10) return min(max_skip, 100);
    if (dc_mag < 1e-8) return min(max_skip, 50);
    if (dc_mag < 1e-6) return min(max_skip, 20);
    
    return 0;
}

// Improved high-precision Mandelbrot (maintains more precision during iteration)
vec3 compute_mandelbrot_highprec(vec2 uv, ivec2 size) {
    // Unpack double-double precision center
    DoubleDouble center_x;
    center_x.hi = PushConstants.data1.x;
    center_x.lo = PushConstants.data1.y;
    
    DoubleDouble center_y;
    center_y.hi = PushConstants.data1.z;
    center_y.lo = PushConstants.data1.w;
    
    DoubleDouble zoom;
    zoom.hi = PushConstants.data2.x;
    zoom.lo = PushConstants.data2.y;
    
    int max_iter = int(PushConstants.data2.z);
    float bailout = PushConstants.data3.z;
    
    // Calculate position with high precision
    
    
    DoubleDouble offset_x;
    offset_x.hi = uv.x; 
    offset_x.lo = 0.0;
    
    DoubleDouble offset_y;
    offset_y.hi = uv.y;
    offset_y.lo = 0.0;
    
    DoubleDouble scaled_x = dd_mul(offset_x, zoom);
    DoubleDouble scaled_y = dd_mul(offset_y, zoom);
    
    DoubleDouble c_x = dd_add(center_x, scaled_x);
    DoubleDouble c_y = dd_add(center_y, scaled_y);
    
    // FIXED: Maintain high precision for the constant c
    // Convert to single precision only for the iteration (acceptable trade-off)
    vec2 c = vec2(dd_to_float(c_x), dd_to_float(c_y));
    
    // For extreme precision needs, could iterate in double-double,
    // but that's 4-8x slower. This is a good compromise.
    vec2 z = vec2(0.0);
    
    int iter;
    float smooth_val = 0.0;
    
    for(iter = 0; iter < max_iter; iter++) {
        float x_temp = z.x * z.x - z.y * z.y + c.x;
        z.y = 2.0 * z.x * z.y + c.y;
        z.x = x_temp;
        
        float len_sq = z.x * z.x + z.y * z.y;
        
        if(len_sq > bailout * bailout) {
            smooth_val = float(iter) + 1.0 - log(log(len_sq) / log(bailout)) / log(2.0);
            break;
        }
    }
    
    if(iter == max_iter) {
        return vec3(0.0);
    } else {
        float color_offset = PushConstants.data3.x;
        float color_scale = PushConstants.data3.y;
        int palette_mode = int(PushConstants.data3.w);
        
        float t = smooth_val / float(max_iter);
        t = color_offset + t * color_scale;
        return get_palette_color(t, palette_mode);
    }
}

// FIXED: Perturbation theory with proper double-double delta calculation
vec3 compute_mandelbrot_perturbation(vec2 uv, ivec2 size) {
    int max_iter = int(PushConstants.data2.z);
    int ref_iter = int(PushConstants.data4.y);
    float bailout = PushConstants.data3.z;
    bool use_series = PushConstants.data4.z > 0.5;
    int series_order = int(PushConstants.data4.w);
    
    // FIXED: Unpack double-double zoom for accurate delta calculation
    DoubleDouble zoom;
    zoom.hi = PushConstants.data2.x;
    zoom.lo = PushConstants.data2.y;
    
    
    
    // FIXED: Calculate delta_c with double-double precision
    DoubleDouble offset_x;
    offset_x.hi = uv.x;
    offset_x.lo = 0.0;
    
    DoubleDouble offset_y;
    offset_y.hi = uv.y;
    offset_y.lo = 0.0;
    
    DoubleDouble delta_c_x_dd = dd_mul(offset_x, zoom);
    DoubleDouble delta_c_y_dd = dd_mul(offset_y, zoom);
    
    // Convert to single precision for iteration (delta is small enough for this)
    vec2 delta_c = vec2(dd_to_float(delta_c_x_dd), dd_to_float(delta_c_y_dd));
    
    // NEW: Series approximation to skip early iterations
    int skip_iter = 0;
    if (use_series && series_order > 0) {
        skip_iter = compute_series_skip(delta_c, min(series_order * 10, ref_iter / 4));
    }
    
    // Perturbation iteration: Z_n = X_n + z_n where X_n is reference
    vec2 delta_z = vec2(0.0);
    int iter;
    float smooth_val = 0.0;
    
    // Start from skip_iter instead of 0
    for(iter = skip_iter; iter < min(max_iter, ref_iter); iter++) {
        vec2 X_n = reference_orbit[iter];
        
        // Perturbation formula: z_{n+1} = 2*X_n*z_n + z_n^2 + delta_c
        vec2 term1 = 2.0 * vec2(X_n.x * delta_z.x - X_n.y * delta_z.y,
                                 X_n.x * delta_z.y + X_n.y * delta_z.x);
        
        vec2 term2 = vec2(delta_z.x * delta_z.x - delta_z.y * delta_z.y,
                          2.0 * delta_z.x * delta_z.y);
        
        delta_z = term1 + term2 + delta_c;
        
        // NEW: Glitch detection - if delta grows too large, perturbation fails
        float delta_mag_sq = delta_z.x * delta_z.x + delta_z.y * delta_z.y;
        float ref_mag_sq = X_n.x * X_n.x + X_n.y * X_n.y;
        
        // If delta is comparable to reference, we have a "glitch"
        // Fall back to direct computation (or mark as black/error color)
        if (delta_mag_sq > ref_mag_sq * 0.5) {
            // Glitch detected - return error color or fallback
            // For now, just mark as in-set (black)
            return vec3(0.0);
        }
        
        // Absolute orbit = reference + delta
        vec2 Z_n = X_n + delta_z;
        float len_sq = Z_n.x * Z_n.x + Z_n.y * Z_n.y;
        
        if(len_sq > bailout * bailout) {
            smooth_val = float(iter) + 1.0 - log(log(len_sq) / log(bailout)) / log(2.0);
            break;
        }
    }
    
    if(iter == max_iter || iter == ref_iter) {
        return vec3(0.0);
    } else {
        float color_offset = PushConstants.data3.x;
        float color_scale = PushConstants.data3.y;
        int palette_mode = int(PushConstants.data3.w);
        
        float t = smooth_val / float(max_iter);
        t = color_offset + t * color_scale;
        return get_palette_color(t, palette_mode);
    }
}

// Supersampling for higher quality
vec3 supersample(vec2 base_uv, ivec2 size, int samples) {
    bool use_perturbation = PushConstants.data2.w > 0.5;
    int ref_iter = int(PushConstants.data4.y);
    
    // FIXED: Check if we actually have reference orbit data
    bool has_reference = (ref_iter > 0);
    
    if (samples <= 1) {
        if (use_perturbation && has_reference) {
            return compute_mandelbrot_perturbation(base_uv, size);
        } else {
            return compute_mandelbrot_highprec(base_uv, size);
        }
    }
    
    vec3 accumulated = vec3(0.0);
    float pixel_size = 1.0 / float(size.y);
    float sample_offset = pixel_size / float(samples);
    
    for (int sx = 0; sx < samples; sx++) {
        for (int sy = 0; sy < samples; sy++) {
            vec2 offset = vec2(float(sx), float(sy)) * sample_offset - 
                         sample_offset * float(samples - 1) * 0.5;
            vec2 sample_uv = base_uv + offset;
            
            if (use_perturbation && has_reference) {
                accumulated += compute_mandelbrot_perturbation(sample_uv, size);
            } else {
                accumulated += compute_mandelbrot_highprec(sample_uv, size);
            }
        }
    }
    
    return accumulated / float(samples * samples);
}

void main() {

        ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    if(texelCoord.x >= size.x || texelCoord.y >= size.y) {
        return;
    }
    
    // Match the working Mandelbrot shader: divide by height
    vec2 uv = (vec2(texelCoord) - vec2(size) * 0.5) / float(size.y);
    
    int samples = int(PushConstants.data4.x);
    vec3 color = supersample(uv, size, samples);
    
    // Tone mapping and gamma
    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2));
    
    imageStore(image, texelCoord, vec4(color, 1.0));
    
}
