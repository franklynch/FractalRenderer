#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba16f, set = 0, binding = 0) uniform image2D image;

// Reference orbit buffer for perturbation theory
layout(std140, set = 0, binding = 1) readonly buffer ReferenceOrbit {
    vec2 reference_orbit[];  // Complex numbers (real, imag)
};

layout(push_constant) uniform constants {
    vec4 data1; // center_x_hi, center_x_lo, center_y_hi, center_y_lo
    vec4 data2; // zoom_hi, zoom_lo, max_iterations, use_perturbation
    vec4 data3; // color_offset, color_scale, bailout, palette_mode
    vec4 data4; // samples_per_pixel, reference_iterations, use_series_approx, series_order
} PushConstants;

// Double-precision emulation for extreme zooms
struct DoubleDouble {
    float hi;
    float lo;
};

// Double-double arithmetic operations
DoubleDouble dd_add(DoubleDouble a, DoubleDouble b) {
    float t1 = a.hi   b.hi;
    float e = t1 - a.hi;
    float t2 = ((b.hi - e)   (a.hi - (t1 - e)))   a.lo   b.lo;
    
    DoubleDouble result;
    result.hi = t1   t2;
    result.lo = t2 - (result.hi - t1);
    return result;
}

DoubleDouble dd_mul(DoubleDouble a, DoubleDouble b) {
    float p = a.hi * b.hi;
    float e = fma(a.hi, b.hi, -p);
    float f = fma(a.hi, b.lo, fma(a.lo, b.hi, e));
    
    DoubleDouble result;
    result.hi = p   f;
    result.lo = f - (result.hi - p);
    return result;
}

DoubleDouble dd_sub(DoubleDouble a, DoubleDouble b) {
    DoubleDouble neg_b;
    neg_b.hi = -b.hi;
    neg_b.lo = -b.lo;
    return dd_add(a, neg_b);
}

// Convert to single precision (for final iteration or bailout check)
float dd_to_float(DoubleDouble a) {
    return a.hi   a.lo;
}

// Create double-double from float
DoubleDouble float_to_dd(float x) {
    DoubleDouble result;
    result.hi = x;
    result.lo = 0.0;
    return result;
}

// Palette functions
vec3 palette_cosine(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a   b * cos(6.28318 * (c * t   d));
}

vec3 palette_fire(float t) {
    vec3 color1 = vec3(0.0, 0.0, 0.0);
    vec3 color2 = vec3(0.5, 0.0, 0.0);
    vec3 color3 = vec3(1.0, 0.5, 0.0);
    vec3 color4 = vec3(1.0, 1.0, 0.0);
    vec3 color5 = vec3(1.0, 1.0, 1.0);
    
    if (t < 0.25) return mix(color1, color2, t * 4.0);
    else if (t < 0.5) return mix(color2, color3, (t - 0.25) * 4.0);
    else if (t < 0.75) return mix(color3, color4, (t - 0.5) * 4.0);
    else return mix(color4, color5, (t - 0.75) * 4.0);
}

vec3 palette_ocean(float t) {
    vec3 color1 = vec3(0.0, 0.0, 0.2);
    vec3 color2 = vec3(0.0, 0.3, 0.6);
    vec3 color3 = vec3(0.0, 0.8, 0.8);
    vec3 color4 = vec3(0.5, 1.0, 1.0);
    
    if (t < 0.33) return mix(color1, color2, t * 3.0);
    else if (t < 0.66) return mix(color2, color3, (t - 0.33) * 3.0);
    else return mix(color3, color4, (t - 0.66) * 3.0);
}

vec3 get_palette_color(float t, int palette_mode) {
    if (palette_mode == 0) return palette_cosine(t);
    else if (palette_mode == 1) return palette_fire(t);
    else if (palette_mode == 2) return palette_ocean(t);
    else return palette_cosine(t);
}

// Series approximation coefficients for deep zoom optimization
int compute_series_skip(vec2 delta_c, int max_skip) {
    float dc_mag = length(delta_c);
    
    if (dc_mag < 1e-10) return min(max_skip, 100);
    if (dc_mag < 1e-8) return min(max_skip, 50);
    if (dc_mag < 1e-6) return min(max_skip, 20);
    
    return 0;
}

// IMPROVED: High-precision Mandelbrot with better glitch detection

// IMPROVED: True double-double precision Mandelbrot
vec3 compute_mandelbrot_highprec(vec2 uv, ivec2 size) {
    // Unpack double-double precision center
    DoubleDouble center_x;
    center_x.hi = PushConstants.data1.x;
    center_x.lo = PushConstants.data1.y;
    
    DoubleDouble center_y;
    center_y.hi = PushConstants.data1.z;
    center_y.lo = PushConstants.data1.w;
    
    DoubleDouble zoom;
    zoom.hi = PushConstants.data2.x;
    zoom.lo = PushConstants.data2.y;
    
    int max_iter = int(PushConstants.data2.z);
    float bailout = PushConstants.data3.z;
    
    // Calculate position with high precision
    DoubleDouble offset_x;
    offset_x.hi = uv.x; 
    offset_x.lo = 0.0;
    
    DoubleDouble offset_y;
    offset_y.hi = uv.y;
    offset_y.lo = 0.0;
    
    DoubleDouble scaled_x = dd_mul(offset_x, zoom);
    DoubleDouble scaled_y = dd_mul(offset_y, zoom);
    
    DoubleDouble c_x = dd_add(center_x, scaled_x);
    DoubleDouble c_y = dd_add(center_y, scaled_y);
    
    // *** FIXED: Use double-double for iteration! ***
    DoubleDouble zx = float_to_dd(0.0);
    DoubleDouble zy = float_to_dd(0.0);
    
    int iter;
    float smooth_val = 0.0;
    
    for(iter = 0; iter < max_iter; iter  ) {
        // z = z^2   c using double-double arithmetic
        DoubleDouble zx2 = dd_mul(zx, zx);
        DoubleDouble zy2 = dd_mul(zy, zy);
        DoubleDouble zxzy = dd_mul(zx, zy);
        
        // New zx = zx^2 - zy^2   cx
        DoubleDouble new_zx = dd_add(dd_sub(zx2, zy2), c_x);
        
        // New zy = 2*zx*zy   cy
        DoubleDouble two_zxzy = dd_add(zxzy, zxzy);  // 2 * zx * zy
        DoubleDouble new_zy = dd_add(two_zxzy, c_y);
        
        zx = new_zx;
        zy = new_zy;
        
        // Check bailout (convert to float for comparison)
        float zx_f = dd_to_float(zx);
        float zy_f = dd_to_float(zy);
        float len_sq = zx_f * zx_f   zy_f * zy_f;
        
        if(len_sq > bailout * bailout) {
            smooth_val = float(iter)   1.0 - log(log(len_sq) / log(bailout)) / log(2.0);
            break;
        }
    }
    
    if(iter == max_iter) {
        return vec3(0.0);
    } else {
        float color_offset = PushConstants.data3.x;
        float color_scale = PushConstants.data3.y;
        int palette_mode = int(PushConstants.data3.w);
        
        float t = smooth_val / float(max_iter);
        t = color_offset   t * color_scale;
        return get_palette_color(t, palette_mode);
    }
}

// IMPROVED: Perturbation theory with better delta calculation
vec3 compute_mandelbrot_perturbation(vec2 uv, ivec2 size) {
    int max_iter = int(PushConstants.data2.z);
    int ref_iter = int(PushConstants.data4.y);
    float bailout = PushConstants.data3.z;
    bool use_series = PushConstants.data4.z > 0.5;
    int series_order = int(PushConstants.data4.w);
    
    // Unpack double-double zoom for accurate delta calculation
    DoubleDouble zoom;
    zoom.hi = PushConstants.data2.x;
    zoom.lo = PushConstants.data2.y;
    
    // Calculate delta_c with double-double precision
    DoubleDouble offset_x;
    offset_x.hi = uv.x;
    offset_x.lo = 0.0;
    
    DoubleDouble offset_y;
    offset_y.hi = uv.y;
    offset_y.lo = 0.0;
    
    DoubleDouble delta_c_x_dd = dd_mul(offset_x, zoom);
    DoubleDouble delta_c_y_dd = dd_mul(offset_y, zoom);
    
    // Convert to single precision for iteration
    vec2 delta_c = vec2(dd_to_float(delta_c_x_dd), dd_to_float(delta_c_y_dd));
    
    // Series approximation to skip early iterations
    int skip_iter = 0;
    if (use_series && series_order > 0) {
        skip_iter = compute_series_skip(delta_c, min(series_order * 10, ref_iter / 4));
    }
    
    // Perturbation iteration
    vec2 delta_z = vec2(0.0);
    int iter;
    float smooth_val = 0.0;
    
    for(iter = skip_iter; iter < min(max_iter, ref_iter); iter  ) {
        vec2 X_n = reference_orbit[iter];
        
        // Perturbation formula: z_{n 1} = 2*X_n*z_n   z_n^2   delta_c
        vec2 term1 = 2.0 * vec2(X_n.x * delta_z.x - X_n.y * delta_z.y,
                                 X_n.x * delta_z.y   X_n.y * delta_z.x);
        
        vec2 term2 = vec2(delta_z.x * delta_z.x - delta_z.y * delta_z.y,
                          2.0 * delta_z.x * delta_z.y);
        
        delta_z = term1   term2   delta_c;
        
        // IMPROVED: Better glitch detection
        float delta_mag_sq = delta_z.x * delta_z.x   delta_z.y * delta_z.y;
        float ref_mag_sq = X_n.x * X_n.x   X_n.y * X_n.y;
        
        // Glitch detection with stricter threshold
        if (delta_mag_sq > ref_mag_sq * 0.25) {
            // Glitch detected - return dim color for debugging
            return vec3(0.1, 0.0, 0.0); // Red tint indicates glitch
        }
        
        // Absolute orbit = reference   delta
        vec2 Z_n = X_n   delta_z;
        float len_sq = Z_n.x * Z_n.x   Z_n.y * Z_n.y;
        
        if(len_sq > bailout * bailout) {
            smooth_val = float(iter)   1.0 - log(log(len_sq) / log(bailout)) / log(2.0);
            break;
        }
    }
    
    if(iter == max_iter || iter == ref_iter) {
        return vec3(0.0);
    } else {
        float color_offset = PushConstants.data3.x;
        float color_scale = PushConstants.data3.y;
        int palette_mode = int(PushConstants.data3.w);
        
        float t = smooth_val / float(max_iter);
        t = color_offset   t * color_scale;
        return get_palette_color(t, palette_mode);
    }
}

// IMPROVED: Supersampling with adaptive precision
vec3 supersample(vec2 base_uv, ivec2 size, int samples) {
    bool use_perturbation = PushConstants.data2.w > 0.5;
    int ref_iter = int(PushConstants.data4.y);
    float zoom_level = PushConstants.data2.x;
    
    bool has_reference = (ref_iter > 0);
    
    // IMPROVED: Disable supersampling at extreme zoom where offsets collapse
    int effective_samples = samples;
    if (zoom_level < 1e-8) {
        effective_samples = 1; // Single sample at extreme zoom
    }
    
    if (effective_samples <= 1) {
        if (use_perturbation && has_reference) {
            return compute_mandelbrot_perturbation(base_uv, size);
        } else {
            return compute_mandelbrot_highprec(base_uv, size);
        }
    }
    
    vec3 accumulated = vec3(0.0);
    float pixel_size = 1.0 / float(size.y);
    float sample_offset = pixel_size / float(effective_samples);
    
    // IMPROVED: Check if sample offset is meaningful
    if (sample_offset * zoom_level < 1e-9) {
        // Offsets too small, just do single sample
        if (use_perturbation && has_reference) {
            return compute_mandelbrot_perturbation(base_uv, size);
        } else {
            return compute_mandelbrot_highprec(base_uv, size);
        }
    }
    
    for (int sx = 0; sx < effective_samples; sx  ) {
        for (int sy = 0; sy < effective_samples; sy  ) {
            vec2 offset = vec2(float(sx), float(sy)) * sample_offset - 
                         sample_offset * float(effective_samples - 1) * 0.5;
            vec2 sample_uv = base_uv   offset;
            
            if (use_perturbation && has_reference) {
                accumulated  = compute_mandelbrot_perturbation(sample_uv, size);
            } else {
                accumulated  = compute_mandelbrot_highprec(sample_uv, size);
            }
        }
    }
    
    return accumulated / float(effective_samples * effective_samples);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(image);
    
    if(texelCoord.x >= size.x || texelCoord.y >= size.y) {
        return;
    }
    
    // IMPROVED: Better UV coordinate calculation with intermediate precision
    vec2 pixel_offset = vec2(texelCoord) - vec2(size) * 0.5;
    vec2 uv = pixel_offset / float(size.y);
    
    int samples = int(PushConstants.data4.x);
    vec3 color = supersample(uv, size, samples);
    
    // Tone mapping and gamma
    color = color / (color   vec3(1.0));
    color = pow(color, vec3(1.0/2.2));
    
    imageStore(image, texelCoord, vec4(color, 1.0));
}
